import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';
import { Cron } from '@nestjs/schedule';
import { format } from 'date-fns';
import { Goal, GoalStatus } from '../entities/goal.entity';
import { Organization } from '../../organization/entities/organization.entity';
import { GoalTrackingService, GoalRiskAnalysis } from './goal-tracking.service';

interface GoalWithRisk {
  goal: Goal;
  risk: GoalRiskAnalysis;
}

interface GoalReviewData {
  organizationId: string;
  totalGoals: number;
  criticalGoals: GoalWithRisk[];
  highRiskGoals: GoalWithRisk[];
  onTrackGoals: GoalWithRisk[];
  reviewDate: Date;
}

@Injectable()
export class GoalReviewService {
  private readonly logger = new Logger(GoalReviewService.name);

  constructor(
    private readonly goalTrackingService: GoalTrackingService,
    @InjectRepository(Goal)
    private readonly goalRepo: Repository<Goal>,
    @InjectRepository(Organization)
    private readonly orgRepo: Repository<Organization>,
  ) {}

  /**
   * Ï£ºÍ∞Ñ Goal Î¶¨Î∑∞ (Îß§Ï£º Í∏àÏöîÏùº 17:00)
   */
  @Cron('0 17 * * 5') // Í∏àÏöîÏùº 17:00
  async weeklyGoalReview(): Promise<void> {
    this.logger.log('Starting weekly goal review...');

    try {
      const organizations = await this.orgRepo.find();

      this.logger.log(
        `Running goal review for ${organizations.length} organizations`,
      );

      for (const org of organizations) {
        try {
          await this.runGoalReview(org.id);
        } catch (error) {
          const err = error as Error;
          this.logger.error(
            `Goal review failed for org ${org.id}: ${err.message}`,
            err.stack,
          );
        }
      }

      this.logger.log('Completed weekly goal review');
    } catch (error) {
      const err = error as Error;
      this.logger.error(
        `Failed to run weekly goal review: ${err.message}`,
        err.stack,
      );
    }
  }

  /**
   * OrganizationÏùò Goal Î¶¨Î∑∞ Ïã§Ìñâ
   */
  private async runGoalReview(organizationId: string): Promise<void> {
    const activeGoals = await this.goalRepo.find({
      where: {
        organizationId,
        status: In([GoalStatus.ACTIVE, GoalStatus.PAUSED]),
      },
      relations: ['ownerHollon', 'team'],
    });

    if (activeGoals.length === 0) {
      this.logger.log(`No active goals for organization ${organizationId}`);
      return;
    }

    // Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù
    const goalsWithRisk = await Promise.all(
      activeGoals.map(async (goal) => ({
        goal,
        risk: await this.goalTrackingService.analyzeGoalRisk(goal.id),
      })),
    );

    // Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®Î≥Ñ Î∂ÑÎ•ò
    const criticalGoals = goalsWithRisk.filter(
      (g) => g.risk.riskLevel === 'critical',
    );
    const highRiskGoals = goalsWithRisk.filter(
      (g) => g.risk.riskLevel === 'high',
    );
    const onTrackGoals = goalsWithRisk.filter(
      (g) => g.risk.riskLevel === 'low',
    );

    // Î¶¨Î∑∞ Î¨∏ÏÑú ÏÉùÏÑ±
    const reviewDocument = this.generateReviewDocument({
      organizationId,
      totalGoals: activeGoals.length,
      criticalGoals,
      highRiskGoals,
      onTrackGoals,
      reviewDate: new Date(),
    });

    // TODO: Document Ï†ÄÏû• - DocumentService Íµ¨ÌòÑ Ïãú ÌôúÏÑ±Ìôî
    // await this.documentService.create({
    //   organizationId,
    //   name: `Goal Review - ${format(new Date(), 'yyyy-MM-dd')}`,
    //   docType: 'meeting',
    //   scope: 'organization',
    //   scopeId: organizationId,
    //   content: reviewDocument,
    //   autoGenerated: true,
    //   keywords: ['goal', 'review', 'weekly', 'okr'],
    //   importance: 7,
    // });

    this.logger.log(
      `Goal review completed for organization ${organizationId}: ${criticalGoals.length} critical, ${highRiskGoals.length} high risk, ${onTrackGoals.length} on track`,
    );
    this.logger.debug(`Review document:\n${reviewDocument}`);

    // Critical GoalÏùÄ Ïù∏Í∞ÑÏóêÍ≤å ÏïåÎ¶º (Ìñ•ÌõÑ Íµ¨ÌòÑ)
    if (criticalGoals.length > 0) {
      this.logger.warn(
        `Organization ${organizationId} has ${criticalGoals.length} critical goals requiring immediate attention`,
      );
      // TODO: await this.notifyHumans(organizationId, criticalGoals);
    }
  }

  /**
   * Î¶¨Î∑∞ Î¨∏ÏÑú ÏÉùÏÑ±
   */
  private generateReviewDocument(data: GoalReviewData): string {
    const {
      totalGoals,
      criticalGoals,
      highRiskGoals,
      onTrackGoals,
      reviewDate,
    } = data;

    return `# Weekly Goal Review - ${format(reviewDate, 'yyyy-MM-dd')}

## Executive Summary

- **Total Active Goals**: ${totalGoals}
- **Critical Risk**: ${criticalGoals.length} goals ‚ö†Ô∏è
- **High Risk**: ${highRiskGoals.length} goals
- **On Track**: ${onTrackGoals.length} goals ‚úÖ

## Critical Goals (Immediate Action Required)

${
  criticalGoals.length === 0
    ? 'No critical goals at this time.\n'
    : criticalGoals
        .map(
          ({ goal, risk }) => `
### ${goal.title}

- **Progress**: ${goal.progressPercent.toFixed(1)}% (Expected: ${(risk.expectedProgress ?? 0).toFixed(1)}%)
- **Gap**: ${(risk.progressGap ?? 0).toFixed(1)}%
- **Remaining Days**: ${risk.remainingDays ?? 'N/A'}
- **Owner**: ${goal.ownerHollon?.name || 'Unassigned'}
- **Recommendation**: ${risk.recommendation}
`,
        )
        .join('\n')
}

## High Risk Goals

${
  highRiskGoals.length === 0
    ? 'No high risk goals at this time.\n'
    : highRiskGoals
        .map(
          ({ goal, risk }) => `
- **${goal.title}**: ${goal.progressPercent.toFixed(1)}% (Gap: ${(risk.progressGap ?? 0).toFixed(1)}%)
`,
        )
        .join('\n')
}

## On Track Goals

${
  onTrackGoals.length === 0
    ? 'No on-track goals at this time.\n'
    : onTrackGoals
        .slice(0, 5)
        .map(
          ({ goal }) => `
- **${goal.title}**: ${goal.progressPercent.toFixed(1)}%
`,
        )
        .join('\n')
}

${onTrackGoals.length > 5 ? `\n... and ${onTrackGoals.length - 5} more goals on track\n` : ''}

## Recommended Actions

${this.generateRecommendations(criticalGoals, highRiskGoals)}

---

*ü§ñ Generated automatically by GoalReviewService*
`;
  }

  /**
   * Í∂åÏû• ÏÇ¨Ìï≠ ÏÉùÏÑ±
   */
  private generateRecommendations(
    criticalGoals: GoalWithRisk[],
    highRiskGoals: GoalWithRisk[],
  ): string {
    const recommendations: string[] = [];

    if (criticalGoals.length > 0) {
      recommendations.push(
        '1. **Address Critical Goals**: Schedule immediate review meetings for critical goals',
      );
    }

    if (highRiskGoals.length > 0) {
      recommendations.push(
        '2. **Rebalance Priorities**: Increase priority for high-risk goals',
      );
    }

    if (recommendations.length === 0) {
      recommendations.push(
        'All goals are on track. Continue current execution.',
      );
    }

    return recommendations.join('\n');
  }

  /**
   * ÏàòÎèô Goal Î¶¨Î∑∞ Ïã§Ìñâ (APIÎ°ú Ìò∏Ï∂ú Í∞ÄÎä•)
   */
  async runManualReview(organizationId: string): Promise<string> {
    await this.runGoalReview(organizationId);
    return 'Goal review completed successfully';
  }
}
