# Hollon-AI: Multi-Agent System SSOT (Single Source of Truth)

> 이 문서는 Hollon-AI 시스템의 개념적 설계를 정의합니다.
> 구체적인 구현(DB 스키마, TypeScript 코드 등)은 [blueprint.md](./blueprint.md)를 참조하세요.

---

## 1. 프로젝트 개요

### 1.1 비전

재귀적 멀티 에이전트 시스템. 회사 조직 구조처럼 동작하는 에이전트들이 계층적으로 협업하여 복잡한 작업을 수행한다.

### 1.2 핵심 개념

**Hollon(홀론)**: 전체이자 부분인 자율적 에이전트 단위
- 그 자체로 완전한 에이전트이면서 동시에 상위 시스템의 부분
- Arthur Koestler의 홀라키(Holarchy) 개념에서 영감
- 각 홀론은 Brain Provider(Claude Code 등)를 통해 실행됨

**Organization(조직)**: 홀론들의 최상위 컨테이너
- 워크스페이스 역할
- 리소스 제한 및 설정 관리
- 복수의 프로젝트 포함 가능

---

## 2. 시스템 아키텍처

### 2.1 전체 구조

```
┌─────────────────────────────────────────────────────────────┐
│                      Web UI (Next.js)                       │
│    - 조직도 시각화 (Argo CD 스타일)                          │
│    - 홀론 상태 모니터링                                      │
│    - 대화 인터페이스                                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Backend Server (Node.js)                 │
│    - 홀론 프로세스 관리                                      │
│    - 메시지 라우팅                                           │
│    - WebSocket 실시간 업데이트                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   PostgreSQL (Data Layer)                   │
│    - 홀론 상태 및 메타데이터                                 │
│    - 대화 히스토리                                           │
│    - 메시지 큐 (LISTEN/NOTIFY)                               │
│    - 프로젝트/태스크 관리                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 Brain Providers (Holons)                    │
│    - 각 홀론 = 독립 프로세스 또는 API 호출                    │
│    - Claude Code, Gemini CLI, Claude API 등                  │
│    - DB 접근을 위한 API 엔드포인트 활용                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 디렉토리 구조

```
hollon-ai/
├── apps/
│   ├── web/                    # Next.js 웹 UI
│   └── server/                 # 백엔드 서버
├── packages/
│   ├── core/                   # 핵심 타입 및 유틸리티
│   ├── db/                     # 데이터베이스 스키마 공유
│   ├── shared/                 # 공유 로직
│   └── ui/                     # 공유 UI 컴포넌트
├── docker/
│   └── docker-compose.yml      # PostgreSQL + 앱 컨테이너
└── docs/
    ├── ssot.md                 # 개념적 설계 (이 문서)
    └── blueprint.md            # 구체적 구현 명세
```

---

## 3. 핵심 엔티티

### 3.1 데이터 모델 개요

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Organization                                    │
└─────────────────────────────────────────────────────────────────────────────┘
       │              │              │              │              │
       ▼              ▼              ▼              ▼              ▼
┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐
│   Role    │  │   Team    │  │  Project  │  │  Channel  │  │ Document  │
└───────────┘  └───────────┘  └───────────┘  └───────────┘  └───────────┘
       │              │              │              │              │
       ▼              ▼              ▼              ▼              │
┌───────────────────────────────────────────────────────────────┐ │
│                          Hollon                                │◄┘
│  (self-ref: parent_id for hierarchy)                          │
└───────────────────────────────────────────────────────────────┘
       │                             │
       ▼                             ▼
┌───────────┐                 ┌───────────┐
│  Message  │                 │   Task    │ (self-ref: parent_id)
└───────────┘                 └───────────┘
```

### 3.2 엔티티 설명

| 엔티티 | 설명 | 회사 비유 |
|--------|------|----------|
| **Organization** | 최상위 컨테이너. 비용/리소스 제한 관리 | 회사 |
| **Role** | 역할 템플릿 (시스템 프롬프트, 권한, 자율성 수준 정의) | 직무 기술서 |
| **Team** | 홀론들의 그룹. 계층 구조 지원 | 부서/팀 |
| **Hollon** | Role 기반 에이전트 인스턴스. 영구/임시 생명주기 | 직원 |
| **Project** | 목표 달성을 위한 작업 묶음 | 프로젝트 |
| **Task** | 재귀적 작업 단위 (Sub-task 지원) | Linear 이슈 |
| **Milestone** | 프로젝트의 중요 이정표 | 마일스톤 |
| **Cycle** | 시간 기반 작업 단위. 예산 추적 포함 | 스프린트 |
| **Channel** | 그룹 커뮤니케이션 공간. 스레드 지원 | Slack 채널 |
| **Document** | Markdown 기반 문서. 재귀적 폴더 구조. 버전 관리 | Wiki/Notion |
| **Message** | 홀론 간 1:1 커뮤니케이션 | DM |

### 3.3 Role (역할 템플릿)

Role은 홀론이 가질 수 있는 역할을 정의하는 템플릿:

- **시스템 프롬프트**: 역할 정의 및 행동 지침
- **권한(Capabilities)**: 허용된 능력 목록
- **의사결정 영역(Decision Domains)**: 최종 결정권을 가지는 영역
- **자율성 수준(Autonomy Level)**: low / medium / high
- **Brain Provider 설정**: 기본으로 사용할 AI 백엔드

**예시 역할:**
- CTO: 기술 전략 수립, 기술팀 총괄, 높은 자율성
- 백엔드 엔지니어: API 개발, DB 설계, 코드 리뷰
- 프로젝트 매니저: 일정 관리, 리소스 조율, 보고

### 3.4 Hollon (역할 인스턴스)

Hollon은 Role을 기반으로 생성된 실제 에이전트 인스턴스:

- **생명주기**: permanent(영구) 또는 temporary(임시)
- **상태**: idle / running / waiting / terminated / error
- **계층 구조**: parent_id를 통한 트리 구조
- **커스터마이징**: Role 설정을 개별 홀론에서 오버라이드 가능
- **Brain Provider 오버라이드**: 홀론별로 다른 AI 백엔드 지정 가능

---

## 4. Brain Provider 아키텍처

### 4.1 개념

홀론의 "두뇌"는 다양한 AI 백엔드를 지원하도록 추상화됩니다. CLI 도구와 API 모두 동일한 인터페이스로 사용 가능합니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Hollon                                     │
│                             │                                        │
│                    ┌────────┴────────┐                              │
│                    │  BrainProvider  │  ← 통합 추상화 계층           │
│                    └────────┬────────┘                              │
│         ┌──────────┬────────┼────────┬──────────┐                   │
│         ▼          ▼        ▼        ▼          ▼                   │
│   ┌──────────┐┌──────────┐┌──────────┐┌──────────┐┌──────────┐     │
│   │  Claude  ││  Gemini  ││  Cursor  ││  Claude  ││  Gemini  │     │
│   │   Code   ││   CLI    ││   CLI    ││   API    ││   API    │     │
│   └──────────┘└──────────┘└──────────┘└──────────┘└──────────┘     │
│   └────────── CLI 기반 (프로세스) ──────┘└─── API 기반 (HTTP) ───┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 설계 원칙

- **통합 인터페이스**: 모든 Brain Provider는 동일한 `IBrainProvider` 인터페이스 구현
- **기본값**: Claude Code를 기본 Brain Provider로 사용
- **확장성**: 새로운 AI 백엔드 추가 시 인터페이스만 구현하면 됨
- **혼합 사용**: Organization / Role / Hollon 레벨에서 다른 Provider 지정 가능

### 4.3 지원 Provider

| Provider | 카테고리 | 코드실행 | 파일시스템 | 웹브라우징 | Context Window |
|----------|---------|---------|-----------|-----------|----------------|
| **claude-code** (기본) | CLI | ✅ | ✅ | ✅ | 200K |
| gemini-cli | CLI | ✅ | ✅ | ✅ | 1M |
| cursor-cli | CLI | ✅ | ✅ | ❌ | 128K |
| claude-api | API | ❌ | ❌ | ❌ | 200K |
| gemini-api | API | ❌ | ❌ | ❌ | 1M |
| openai-api | API | ❌ | ❌ | ❌ | 128K |

### 4.4 Provider 선택 우선순위

```
Hollon 설정 > Role 설정 > Organization 기본값 > Claude Code (시스템 기본)
```

---

## 5. 핵심 기능

### 5.1 Task 기반 운영 모델

홀론은 **Single Context 원칙**에 따라 운영됩니다. 하나의 컨텍스트에서 하나의 태스크를 완료하고, 다음 태스크를 가져옵니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    Task Pool (기존 Task 엔티티)              │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐             │
│  │ todo │ │ todo │ │ todo │ │ done │ │ done │             │
│  │ P:H  │ │ P:M  │ │ P:L  │ │      │ │      │             │
│  └──┬───┘ └──────┘ └──────┘ └──────┘ └──────┘             │
│     │                                                       │
│     ▼                                                       │
│  Hollon이 우선순위에 따라 Pull                               │
└─────────────────────────────────────────────────────────────┘

홀론 실행 사이클:
1. Task Pull → 2. Context 시작 → 3. 작업 수행 → 4. 결과 저장 → 5. Context 종료 → (반복)
```

**태스크 선택 알고리즘:**
1. 홀론에게 직접 할당된 태스크 (`assignee_id = hollon_id`)
2. 홀론이 속한 팀의 미할당 태스크 (우선순위 높은 순)
3. 홀론의 Role과 매칭되는 태스크 (라벨/카테고리 기반)

**Single Context 원칙의 이점:**
- 컨텍스트 유실 문제 해결 (매 태스크가 독립적)
- 명확한 작업 단위와 측정 가능한 성과
- 실패 시 영향 범위 최소화
- 병렬 처리 용이

### 5.2 작업 위임 및 분할

홀론은 받은 태스크를 분석하여 직접 수행하거나 서브태스크로 분할:

```
1. 홀론이 태스크 Pull
   │
2. 복잡도 분석 (LLM 판단)
   ├── 예상 토큰 소모량
   ├── 필요한 도메인 지식
   ├── 예상 소요 시간
   └── 서브태스크 분할 가능성
   │
3. 분기 결정
   ├── 단순 작업 → 직접 수행
   ├── 복잡 작업 → 서브태스크 생성 후 재귀적 처리
   │
4. 작업 완료
   ├── 결과를 Document로 저장 (필요시)
   ├── 태스크 상태 업데이트
   └── 다음 태스크 Pull
```

### 5.3 홀론 간 통신

PostgreSQL LISTEN/NOTIFY를 활용한 실시간 메시지 교환:

```
발신 홀론                       수신 홀론
    │                              │
    ├── API로 메시지 전송 ─────────┤
    │         │                    │
    │    DB INSERT 발생            │
    │         │                    │
    │    NOTIFY 트리거 실행        │
    │         │                    │
    │    Server가 LISTEN 중 ───────┤
    │         │                    │
    │    WebSocket으로 전달 ───────┤
    │                              │
    │ ◄─────── 응답 (역방향) ──────┤
```

### 5.4 Human-in-the-Loop

사용자 승인이 필요한 액션:

| 액션 | 승인 필요 조건 |
|------|----------------|
| 새 홀론 생성 | 항상 |
| 영구 홀론 삭제 | 항상 |
| 외부 API 호출 | 설정에 따라 |
| 파일 시스템 수정 | 허용 경로 외 접근 시 |
| 높은 비용 작업 | 임계값 초과 시 |

### 5.5 비용 통제

- **Organization 레벨**: 일일/월간 비용 한도
- **Team 레벨**: 사이클별 예산 할당
- **Hollon 레벨**: 서브 홀론 생성 예산
- **시간대별 제한**: 업무시간/야간/주말별 동시 홀론 수 제한

### 5.6 자기 개선 시스템

- **사이클 회고**: 매 사이클 종료 시 자동 회고 생성
- **개선 제안**: 메트릭 분석 기반 프롬프트/프로세스 개선 제안
- **A/B 테스트**: 프롬프트, 모델, 프로세스 실험
- **프롬프트 버전 관리**: 변경 이력 및 성과 스냅샷 저장

---

## 6. 프롬프트 계층 구조

### 6.1 개념

홀론이 실행될 때, 여러 계층의 프롬프트가 합성되어 최종 시스템 프롬프트를 구성합니다. 이를 통해 조직의 맥락, 팀의 규칙, 역할의 전문성이 자연스럽게 전달됩니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    최종 합성 프롬프트                         │
├─────────────────────────────────────────────────────────────┤
│  Layer 1: Organization Context                              │
│  ├── 회사 비전, 핵심 가치, 전사 규칙                          │
│  └── 예: "우리는 사용자 중심의 제품을 만든다..."               │
├─────────────────────────────────────────────────────────────┤
│  Layer 2: Team Context                                      │
│  ├── 팀 목표, 협업 규칙, 커뮤니케이션 스타일                   │
│  └── 예: "엔지니어링 팀은 코드 리뷰 필수..."                   │
├─────────────────────────────────────────────────────────────┤
│  Layer 3: Role Prompt                                       │
│  ├── 역할 정의, 전문 지식, 의사결정 권한                       │
│  └── 예: "당신은 백엔드 엔지니어로서..."                       │
├─────────────────────────────────────────────────────────────┤
│  Layer 4: Hollon Custom Prompt                              │
│  ├── 개별 홀론의 성격, 특화 영역, 학습된 선호도                 │
│  └── 예: "TypeScript와 PostgreSQL에 특화..."                 │
├─────────────────────────────────────────────────────────────┤
│  Layer 5: Long-term Memory (Document)                       │
│  ├── 관련 문서, 이전 작업 결과, 학습된 패턴                    │
│  └── 예: "[API 설계 가이드], [이전 리팩토링 결과]..."          │
├─────────────────────────────────────────────────────────────┤
│  Layer 6: Current Task Context                              │
│  ├── 현재 태스크 설명, 관련 서브태스크, 우선순위               │
│  └── 예: "Task #123: 사용자 인증 API 구현..."                 │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 재귀적 홀론의 프롬프트 상속

영구 홀론이 서브 홀론을 생성할 때, 상위 홀론의 컨텍스트가 자동으로 상속됩니다:

```
Parent Hollon (CTO)
├── Organization Context ─────────────────┐
├── Team Context (Engineering) ───────────┼──▶ 상속
├── Role Prompt (CTO) ────────────────────┤
├── Hollon Custom ────────────────────────┘
│
└── Child Hollon (임시 조사 담당)
    ├── [상속됨] Organization Context
    ├── [상속됨] Team Context
    ├── [상속됨] Parent의 관련 맥락 (요약)
    ├── Role Prompt (Research Assistant)
    └── Task Context (특정 조사 태스크)
```

### 6.3 프롬프트 합성 규칙

| 계층 | 소스 | 우선순위 | 충돌 시 |
|------|------|---------|--------|
| Organization | `organizations.context_prompt` | 최저 | 기본값 |
| Team | `teams.context_prompt` | 낮음 | 조직 규칙 위에 추가 |
| Role | `roles.system_prompt` | 중간 | 역할별 특화 |
| Hollon | `hollons.custom_prompt` | 높음 | 역할 설정 오버라이드 |
| Memory | 자동 선택된 Document들 | 높음 | 관련성 기반 주입 |
| Task | 현재 태스크 정보 | 최고 | 즉시 맥락 |

---

## 7. Document 기반 Memory 시스템

### 7.1 통합 개념

Document 시스템이 Long-term Memory 역할을 겸합니다. 명시적 문서(스펙, 가이드)와 암묵적 학습(작업 결과, 회고)이 하나의 시스템에서 관리됩니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    Document = Memory                         │
├─────────────────────────────────────────────────────────────┤
│  명시적 문서 (Human Created)                                 │
│  ├── spec: 기술 명세서                                       │
│  ├── guide: 가이드/매뉴얼                                    │
│  ├── adr: 아키텍처 결정 기록                                  │
│  └── runbook: 운영 절차서                                    │
├─────────────────────────────────────────────────────────────┤
│  암묵적 메모리 (Auto Generated)                              │
│  ├── memory: 학습된 패턴, 선호도                              │
│  ├── postmortem: 장애/실패 분석                              │
│  ├── meeting: 회의/논의 기록                                 │
│  └── changelog: 변경 이력                                    │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 Document 속성 확장

| 속성 | 설명 | 용도 |
|------|------|------|
| **scope** | organization / team / project / hollon | 문서의 적용 범위 |
| **doc_type** | spec, adr, guide, memory, postmortem 등 | 문서 분류 |
| **keywords** | 검색/매칭용 키워드 배열 | 관련 문서 찾기 |
| **importance** | 1-10 중요도 점수 | 주입 우선순위 |
| **auto_generated** | 자동 생성 여부 | 사람/홀론 작성 구분 |
| **expires_at** | 만료 시점 (optional) | 임시 메모리 정리 |

### 7.3 Memory 주입 흐름

태스크 시작 시, 관련 Document가 자동으로 프롬프트에 주입됩니다:

```
태스크 시작
    │
    ▼
┌─────────────────────────────────┐
│  1. 키워드 추출                  │
│     태스크 설명에서 핵심 키워드   │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  2. 관련 Document 검색           │
│     - scope 매칭 (hollon→team→org)│
│     - keywords 매칭              │
│     - 최근 access 가중치         │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  3. 중요도 기반 선택             │
│     - importance 점수순 정렬     │
│     - 컨텍스트 한도 내 선택       │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  4. 프롬프트 Layer 5에 주입      │
│     [문서 요약 또는 전문]         │
└─────────────────────────────────┘
```

### 7.4 자동 Memory 생성

홀론이 태스크 완료 시, 학습 가치가 있는 내용은 자동으로 Document화:

| 트리거 | 생성되는 문서 | scope |
|--------|-------------|-------|
| 태스크 완료 (복잡도 높음) | 작업 요약 memory | hollon |
| 반복 실패 후 성공 | 문제 해결 패턴 memory | team |
| 새로운 라이브러리 사용 | 사용법 guide | project |
| 아키텍처 결정 | ADR | project/team |
| 사이클 회고 | postmortem | team |

---

## 8. 자율 운영 정책

### 8.1 운영 철학

**"사람은 이사회"** - 인간은 전략적 결정과 예외 상황에만 개입합니다. 일상적인 운영은 홀론들이 자율적으로 수행합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                        인간 (이사회)                         │
│  ├── 전략적 방향 설정                                        │
│  ├── 영구 홀론 생성/삭제 승인                                 │
│  ├── 예산 초과 승인                                          │
│  └── 중대한 예외 상황 판단                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼ (최소한의 개입)
┌─────────────────────────────────────────────────────────────┐
│                    자율 운영 영역                             │
│  ├── 태스크 할당 및 처리                                     │
│  ├── 서브태스크 생성                                         │
│  ├── 임시 홀론 생성/종료                                     │
│  ├── Document 생성/수정                                      │
│  ├── 홀론 간 협업/커뮤니케이션                                │
│  └── 일반적인 의사결정                                       │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 Action Policy Matrix

| 액션 | 정책 | 조건 |
|------|------|------|
| 태스크 처리 | `autonomous` | - |
| 서브태스크 생성 | `autonomous` | - |
| 임시 홀론 생성 | `autonomous` | 예산 범위 내 |
| Document 생성/수정 | `autonomous` | - |
| 홀론 간 메시지 | `autonomous` | - |
| 외부 API 호출 | `autonomous` | 허용 목록 내 |
| **영구 홀론 생성** | `requires_approval` | 항상 |
| **영구 홀론 삭제** | `requires_approval` | 항상 |
| **예산 초과 작업** | `requires_approval` | 임계값 초과 시 |
| **허용 외 파일 접근** | `requires_approval` | 샌드박스 외 |
| **전략적 방향 변경** | `requires_approval` | 항상 |

### 8.3 에스컬레이션 계층

문제 발생 시 자동 에스컬레이션:

```
Level 1: 자기 해결
    │     홀론이 자체적으로 재시도, 대안 탐색
    │
    ▼ (실패 시)
Level 2: 팀 내 협업
    │     같은 팀 홀론에게 도움 요청
    │
    ▼ (해결 불가 시)
Level 3: 팀 리더 판단
    │     팀 리더 홀론이 우선순위 조정, 리소스 재배치
    │
    ▼ (권한 밖 시)
Level 4: 상위 팀/조직 레벨
    │     더 넓은 범위의 결정 필요
    │
    ▼ (중대 사안 시)
Level 5: 인간 개입 요청
          이사회 수준의 결정 필요
```

### 8.4 품질 게이트

자율 운영의 품질을 보장하기 위한 자동 검증:

| 게이트 | 검증 내용 | 실패 시 |
|--------|----------|---------|
| 태스크 완료 검증 | 결과물 존재, 포맷 준수 | 재작업 요청 |
| 코드 품질 검증 | 린트, 테스트 통과 | 자동 수정 시도 |
| 비용 검증 | 예산 범위 내 | 작업 중단, 승인 요청 |
| 시간 검증 | SLA 내 완료 | 우선순위 상향 |
| 의존성 검증 | 블로커 태스크 완료 | 대기 또는 에스컬레이션 |

### 8.5 LLM 한계 극복 전략

홀론의 두뇌인 LLM의 근본적 한계를 시스템 레벨에서 보완합니다.

#### 8.5.1 한계 및 대응 매트릭스

| LLM 한계 | 영향 | 시스템 대응 |
|---------|------|------------|
| **컨텍스트 윈도우 제한** | 긴 작업 처리 불가 | Single Context 원칙 + 태스크 분할 |
| **상태 비저장 (Stateless)** | 이전 작업 기억 못함 | Document-Memory 시스템 |
| **할루시네이션** | 잘못된 정보 생성 | FactCheckService + 코드 실행 검증 |
| **일관성 없는 출력** | 같은 입력, 다른 결과 | DecisionLogService + ConsistencyEnforcer |
| **장기 계획 능력 부족** | 복잡한 계획 수립 어려움 | GoalDecompositionService |
| **자기 인식 부재** | 자신의 한계 모름 | 5단계 Escalation + 자동 에러 감지 |
| **실시간 정보 부재** | 최신 정보 접근 불가 | ExternalKnowledgeService |

#### 8.5.2 일관성 보장 (DecisionLogService)

모든 중요 결정을 강제 기록하고, 동일 맥락에서 자동 참조합니다.

```
의사결정 흐름:
1. 홀론이 결정 필요한 상황 도달
   │
2. 기존 결정 검색 (DecisionLog)
   ├── 동일/유사 결정 존재 → 기존 결정 따름
   └── 없음 → 새 결정 수행
       │
3. 새 결정 시 기록 필수
   ├── 질문: "어떤 DB를 쓸까?"
   ├── 선택지: [PostgreSQL, MySQL, MongoDB]
   ├── 결정: PostgreSQL
   ├── 근거: "관계형 데이터, 트랜잭션 필요"
   └── 맥락: project_id, task_id
       │
4. 이후 동일 맥락에서 자동 주입
```

**Decision 유형:**
- `architecture`: 기술 스택, 패턴 선택
- `naming`: 명명 규칙, 컨벤션
- `process`: 워크플로우, 절차
- `priority`: 우선순위, 트레이드오프

#### 8.5.3 할루시네이션 방지 (FactCheckService)

생성된 결과물의 사실 여부를 자동 검증합니다.

```
검증 계층:
┌─────────────────────────────────────────────────────────────┐
│  Level 1: 구문 검증 (Syntax)                                 │
│  ├── 코드: 파싱 가능 여부                                    │
│  ├── JSON/YAML: 유효성                                       │
│  └── 마크다운: 구조 검증                                     │
├─────────────────────────────────────────────────────────────┤
│  Level 2: 실행 검증 (Execution)                              │
│  ├── 코드: 컴파일/인터프리트 성공                            │
│  ├── 테스트: 단위 테스트 통과                                │
│  └── 빌드: 빌드 성공 여부                                    │
├─────────────────────────────────────────────────────────────┤
│  Level 3: 참조 검증 (Reference)                              │
│  ├── 패키지: npm/pip 존재 여부, 버전 유효성                  │
│  ├── API: 엔드포인트 존재, 스키마 일치                       │
│  └── 파일: 참조 파일 존재 여부                               │
├─────────────────────────────────────────────────────────────┤
│  Level 4: 의미 검증 (Semantic) - 선택적                      │
│  ├── 문서 교차 검증                                          │
│  └── 다른 홀론 리뷰 (코드 리뷰)                              │
└─────────────────────────────────────────────────────────────┘
```

#### 8.5.4 스타일 일관성 (ConsistencyEnforcer)

프로젝트/팀별 스타일 가이드를 자동 적용합니다.

| 영역 | 강제 항목 | 적용 방식 |
|------|----------|----------|
| **코드** | 네이밍 컨벤션, 파일 구조, 포맷팅 | Linter + 자동 수정 |
| **문서** | 템플릿, 섹션 구조, 용어 | 템플릿 매칭 |
| **커밋** | 메시지 포맷, 브랜치명 | Git Hook 검증 |
| **API** | 엔드포인트 패턴, 응답 형식 | OpenAPI 스키마 검증 |

```
적용 흐름:
홀론 결과물 → ConsistencyEnforcer → 스타일 위반 감지
                                      │
                    ┌─────────────────┴─────────────────┐
                    ▼                                   ▼
              자동 수정 가능                       자동 수정 불가
                    │                                   │
                    ▼                                   ▼
              자동 수정 적용                     피드백과 함께 재작업 요청
```

#### 8.5.5 실시간 정보 접근 (ExternalKnowledgeService)

홀론이 최신 정보에 접근할 수 있도록 외부 지식 서비스를 제공합니다.

| 정보 유형 | 소스 | 사용 예시 |
|----------|------|----------|
| **패키지 정보** | npm, PyPI, Maven | 최신 버전, 호환성 체크 |
| **API 문서** | OpenAPI specs | 외부 API 연동 |
| **공식 문서** | 허용된 URL 목록 | 라이브러리 사용법 |
| **내부 시스템 상태** | 모니터링 API | 현재 서버 상태, 에러 로그 |

```
정보 접근 정책:
┌─────────────────────────────────────────────────────────────┐
│  허용 (Whitelist)                                            │
│  ├── 공식 패키지 레지스트리 (npm, PyPI, etc.)                │
│  ├── 등록된 외부 API 문서                                    │
│  ├── 조직 내부 API                                           │
│  └── 승인된 문서 사이트 목록                                  │
├─────────────────────────────────────────────────────────────┤
│  제한 (Rate Limited)                                         │
│  ├── 분당 요청 수 제한                                       │
│  └── 캐싱 적용 (TTL: 1시간)                                  │
├─────────────────────────────────────────────────────────────┤
│  금지 (Blocked)                                              │
│  ├── 임의의 웹 검색                                          │
│  ├── 미승인 외부 서비스                                      │
│  └── 민감 정보 포함 가능 소스                                │
└─────────────────────────────────────────────────────────────┘
```

#### 8.5.6 수용해야 하는 한계

시스템으로 완전히 해결할 수 없는 LLM의 근본적 한계:

| 한계 | 대응 전략 |
|------|----------|
| **100% 할루시네이션 방지 불가** | 중요 결과물은 인간 검토 필수 |
| **창의적 판단 품질 불확실** | 전략적 결정은 승인 필요 |
| **예측 불가능한 에지 케이스** | 에스컬레이션 + 인간 개입 |
| **복잡한 추론의 한계** | 단계별 분해 + 중간 검증 |

---

## 9. 협업 및 커뮤니케이션

### 9.1 정기 회의 자동화

스타트업 애자일 프로세스를 자동화합니다.

| 회의 유형 | 트리거 | 참여자 | 결과물 |
|----------|-------|--------|--------|
| **데일리 스탠드업** | 매일 지정 시간 | 팀 전체 | 진행상황 요약 Document |
| **스프린트 플래닝** | 사이클 시작 | 팀 리더 + 팀원 | 태스크 할당 계획 |
| **백로그 그루밍** | 주 1회 | PM 홀론 + 관련자 | 정제된 태스크 목록 |
| **스프린트 회고** | 사이클 종료 | 팀 전체 | 회고 Document + 개선 액션 |
| **1:1 미팅** | 주 1회 | 팀 리더 ↔ 팀원 | 피드백 기록 |

```
스탠드업 자동화 흐름:
1. Cron 트리거 (매일 09:00)
   │
2. 각 홀론에게 상태 요청
   ├── 어제 완료한 것
   ├── 오늘 할 것
   └── 블로커
   │
3. 응답 수집 및 집계
   │
4. 스탠드업 Document 생성
   ├── 팀별 요약
   ├── 블로커 하이라이트
   └── 전체 진행률
   │
5. Channel에 공유 + 인간에게 알림 (옵션)
```

### 9.2 크로스팀 협업

팀 간 의존성과 협업을 관리합니다.

```
크로스팀 요청 흐름:
┌─────────────┐         ┌─────────────┐
│   Team A    │         │   Team B    │
│  (요청자)   │         │  (제공자)   │
└──────┬──────┘         └──────┬──────┘
       │                       │
       │  1. 의존성 요청        │
       │  ────────────────────▶│
       │                       │
       │                       │ 2. 요청 검토
       │                       │    (Team B 리더)
       │                       │
       │  3. 수락/협상/거절     │
       │  ◀────────────────────│
       │                       │
       │  4. 인터페이스 계약    │
       │  ◀───────────────────▶│
       │     (Contract)        │
       │                       │
       │  5. 작업 진행 및 전달  │
       │  ◀────────────────────│
```

**Contract (인터페이스 계약):**
- 제공 범위, API 스펙
- 일정, 우선순위
- 변경 시 통보 의무

### 9.3 긴급 대응 (Incident Response)

긴급 상황 발생 시 자동 대응 프로세스:

```
┌─────────────────────────────────────────────────────────────┐
│                    Incident 감지                             │
│  ├── 테스트 실패 급증                                        │
│  ├── 빌드 연속 실패                                          │
│  ├── 비용 급증 경보                                          │
│  └── 외부 서비스 장애                                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    자동 대응                                  │
│  1. 비필수 태스크 일시 중단                                   │
│  2. Incident Owner 자동 할당 (관련 팀 리더)                   │
│  3. 영향 범위 분석                                            │
│  4. 인간에게 즉시 알림 (P1/P2)                                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    해결 후                                    │
│  1. Postmortem 자동 생성                                     │
│  2. 재발 방지 태스크 생성                                     │
│  3. 관련 Document 업데이트                                    │
└─────────────────────────────────────────────────────────────┘
```

**Incident 심각도:**
| 등급 | 기준 | 대응 |
|------|------|------|
| **P1** | 전체 시스템 영향, 작업 불가 | 즉시 인간 알림 + 모든 작업 중단 |
| **P2** | 주요 기능 영향 | 인간 알림 + 관련 작업 중단 |
| **P3** | 부분 영향 | 홀론 자체 해결 시도 |
| **P4** | 경미한 이슈 | 백로그에 추가 |

### 9.4 전략 변경 대응 (Pivot Response)

스타트업의 핵심 특징인 전략 변경(피벗)에 대응하는 메커니즘입니다.

#### 인간 승인 필요 vs 자율 처리

| 상황 | 처리 주체 | 이유 |
|------|----------|------|
| **전략 방향 변경 결정** | 🧑 인간 | 비즈니스 판단 필요 |
| **기존 Goal 폐기/수정** | 🧑 인간 | 투자 손실 결정 |
| **새 Goal 설정** | 🧑 인간 | 전략적 방향 설정 |
| 영향받는 태스크 식별 | 🤖 홀론 | 기계적 분석 가능 |
| 진행 중 태스크 일시 중단 | 🤖 홀론 | 자동화 가능 |
| 재활용 가능 작업물 분류 | 🤖 홀론 | 기술적 판단 |
| 새 Goal → 태스크 분해 | 🤖 홀론 | GoalDecomposition 활용 |
| 리소스 재배치 제안 | 🤖 홀론 | 최적화 알고리즘 |

#### 피벗 대응 흐름

```
┌─────────────────────────────────────────────────────────────┐
│                    1. 인간이 피벗 선언                        │
│       "B2C → B2B로 전환한다" (Goal 변경 승인)                 │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              2. PivotResponseService (자율 처리)              │
│                                                               │
│  2a. 영향 분석                                                │
│      ├── 현재 진행 중인 태스크 식별                           │
│      ├── 영향받는 프로젝트/마일스톤 목록화                     │
│      └── 예상 손실 비용 계산                                  │
│                                                               │
│  2b. 작업 중단                                                │
│      ├── 관련 태스크 상태 → 'suspended'                       │
│      ├── 진행 중인 홀론에 중단 신호                           │
│      └── 부분 완료 결과물 저장                                │
│                                                               │
│  2c. 자산 분류                                                │
│      ├── 재활용 가능: 새 방향에 적용 가능한 코드/문서          │
│      ├── 보관: 나중에 쓸 수 있는 작업물                       │
│      └── 폐기: 새 방향과 완전히 무관한 것                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              3. 인간에게 보고 및 확인 요청                     │
│  ├── 영향 분석 결과 리포트                                    │
│  ├── 재활용/보관/폐기 분류 제안                               │
│  └── 새 Goal 기반 태스크 분해 초안                            │
│                                                               │
│              [승인] / [수정 요청]                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    4. 새 방향 실행 (자율)                      │
│  ├── 승인된 태스크 활성화                                     │
│  ├── 홀론 재배치                                              │
│  └── 정상 운영 재개                                           │
└─────────────────────────────────────────────────────────────┘
```

#### 태스크 상태 확장

피벗 대응을 위해 태스크 상태에 추가:

| 상태 | 설명 |
|------|------|
| `suspended` | 전략 변경으로 일시 중단됨 |
| `deprecated` | 전략 변경으로 폐기됨 (기록용 보관) |
| `migrating` | 새 방향으로 전환 중 |

### 9.5 불확실성 하 의사결정 (Uncertainty Decision)

정보가 불완전한 상황에서의 의사결정 메커니즘입니다.

#### 인간 승인 필요 vs 자율 처리

| 상황 | 처리 주체 | 이유 |
|------|----------|------|
| **되돌릴 수 없는 결정** | 🧑 인간 | 리스크 관리 |
| **비용 임계값 초과 실험** | 🧑 인간 | 예산 통제 |
| **외부 이해관계자 영향** | 🧑 인간 | 관계 관리 |
| 기술적 선택 (A vs B 라이브러리) | 🤖 홀론 | 롤백 가능 |
| 구현 방식 선택 | 🤖 홀론 | 롤백 가능 |
| Time-boxed 실험 | 🤖 홀론 | 비용 한도 내 |
| 가설 검증 후 방향 결정 | 🤖 홀론 | 데이터 기반 |

#### 불확실성 유형 및 대응

```
┌─────────────────────────────────────────────────────────────┐
│                    불확실성 유형 분류                         │
├─────────────────────────────────────────────────────────────┤
│  Type A: 정보 부족 (Information Gap)                         │
│  ├── "이 라이브러리 성능이 충분할까?"                         │
│  └── 대응: 빠른 PoC → 검증 → 결정                            │
│                                                               │
│  Type B: 선택지 동등 (Equivalent Options)                    │
│  ├── "PostgreSQL vs MySQL 둘 다 가능한데..."                 │
│  └── 대응: 기존 결정 참조 또는 기본값 선택                    │
│                                                               │
│  Type C: 미래 예측 불가 (Future Uncertainty)                 │
│  ├── "사용자가 이 기능을 좋아할까?"                          │
│  └── 대응: 최소 구현 → 피드백 수집 → 반복                    │
│                                                               │
│  Type D: 전략적 불확실성 (Strategic Uncertainty)             │
│  ├── "이 시장에 진입해야 할까?"                              │
│  └── 대응: 🧑 인간 에스컬레이션 (홀론 판단 범위 밖)          │
└─────────────────────────────────────────────────────────────┘
```

#### 자율 의사결정 프레임워크

홀론이 불확실성 하에서 자율적으로 결정할 수 있는 프레임워크:

```
의사결정 필요 상황 발생
         │
         ▼
┌─────────────────────────────────────┐
│     1. 되돌릴 수 있는가? (Reversible)│
│     └── 코드 변경, 설정 변경 등      │
└─────────────────────────────────────┘
         │
    Yes ─┴─ No → 🧑 인간 에스컬레이션
         │
         ▼
┌─────────────────────────────────────┐
│     2. 비용 한도 내인가?             │
│     └── 실험 비용 < 허용 임계값      │
└─────────────────────────────────────┘
         │
    Yes ─┴─ No → 🧑 인간 에스컬레이션
         │
         ▼
┌─────────────────────────────────────┐
│     3. 외부 영향 없는가?             │
│     └── 내부 시스템만 영향           │
└─────────────────────────────────────┘
         │
    Yes ─┴─ No → 🧑 인간 에스컬레이션
         │
         ▼
┌─────────────────────────────────────┐
│     4. 자율 결정 실행                │
│     ├── 결정 내용 DecisionLog 기록   │
│     ├── 실행 및 결과 모니터링        │
│     └── 실패 시 롤백 또는 대안 시도  │
└─────────────────────────────────────┘
```

#### Time-boxed 실험 (Spike)

불확실성 해소를 위한 시간 제한 실험:

```
Spike 태스크 생성
├── 목적: "Redis vs Memcached 성능 비교"
├── 시간 제한: 4시간
├── 비용 제한: $5
├── 성공 기준: "1000 TPS 이상 처리 가능"
└── 실패 시: 기본값 선택 또는 인간 에스컬레이션

실행 흐름:
1. 홀론이 Spike 태스크 Pull
2. Time-box 내 실험 수행
3. 결과 기록 (Document)
4. 결과 기반 본 태스크 결정
   ├── 명확한 승자 → 해당 옵션 선택
   ├── 동등함 → 기본값 또는 기존 결정 따름
   └── 판단 불가 → 인간 에스컬레이션
```

#### 가설 기반 실행

```
가설 설정
├── "사용자는 다크모드를 원할 것이다"
├── 검증 방법: A/B 테스트 또는 최소 구현
├── 성공 지표: 활성화율 > 30%
└── 검증 기간: 1주일

실행:
1. 최소 기능 구현 (MVP)
2. 배포 및 지표 수집
3. 결과 분석
   ├── 가설 검증됨 → 본격 개발
   ├── 가설 기각됨 → 롤백 및 대안 탐색
   └── 데이터 불충분 → 기간 연장 또는 인간 판단 요청
```

#### 에스컬레이션 기준 명확화

불확실성 상황에서 **반드시** 인간에게 에스컬레이션해야 하는 경우:

| 상황 | 이유 | 예시 |
|------|------|------|
| **되돌릴 수 없는 결정** | 실수 복구 불가 | 데이터 삭제, 외부 API 계약 |
| **비용 임계값 초과** | 예산 통제 | 예상 비용 > 일일 한도의 50% |
| **외부 영향** | 관계 리스크 | 고객 대면, 파트너 API 변경 |
| **전략적 방향** | 비즈니스 판단 | 시장 선택, 가격 정책 |
| **법적/규정 관련** | 컴플라이언스 | 개인정보, 라이선스 |
| **반복 실패 (3회 이상)** | 판단 한계 도달 | 같은 문제 계속 발생 |

---

## 10. 성과 측정 (Metrics)

### 10.1 측정 대상

- **홀론**: 태스크 완료율, 평균 완료 시간, 품질 점수, 비용 효율성
- **팀**: 벨로시티, 팀 건강도, 협업 지수
- **프로젝트**: 진행률, 예산 사용률, 마일스톤 달성률
- **사이클**: 목표 달성률, 번다운 차트

### 10.2 기본 메트릭

| 메트릭 | 유형 | 적용 대상 | 목표 방향 |
|--------|------|----------|----------|
| 태스크 완료율 | ratio | 홀론, 팀, 프로젝트 | higher |
| 사이클 벨로시티 | gauge | 팀, 프로젝트 | - |
| 평균 태스크 완료 시간 | duration | 홀론, 팀 | lower |
| 태스크당 평균 비용 | gauge | 홀론, 팀 | lower |

---

## 11. 웹 UI 설계

### 11.1 주요 화면

**조직도 뷰 (메인)**
- Argo CD 스타일의 노드 그래프
- 각 홀론을 노드로 표시
- 상태에 따른 색상 구분 (녹색: 실행 중, 파란색: 대기, 회색: 유휴, 빨간색: 오류)
- 계층 구조 시각화

**홀론 상세 뷰**
- 현재 작업 내용
- 대화 히스토리
- 할당된 태스크
- 자식 홀론 목록
- 실시간 로그 스트림

**프로젝트 관리 뷰**
- 프로젝트 목록
- 칸반 보드 스타일 태스크 관리
- 진행 상황 대시보드

**대화 인터페이스**
- 특정 홀론과의 1:1 대화
- 여러 홀론이 포함된 그룹 대화
- 명령어 전송 기능

---

## 12. 구현 로드맵

### Phase 1: MVP 코어 (자율 실행 엔진)

핵심 목표: **홀론이 태스크를 자율적으로 Pull → 실행 → 완료하는 사이클 구현**

```
Week 1-2: 인프라 및 데이터 계층
├── 모노레포 설정 (pnpm workspace + Turborepo)
├── Docker Compose (PostgreSQL 16)
├── NestJS 프로젝트 구조
├── TypeORM Entity 정의 (Organization, Team, Role, Hollon, Task)
└── 기본 CRUD API

Week 3-4: Brain Provider 및 오케스트레이션
├── IBrainProvider 인터페이스
├── ClaudeCodeProvider 구현
├── HollonOrchestratorService (태스크 사이클)
├── TaskPoolService (Pull 방식 태스크 할당)
└── PromptComposerService (6계층 프롬프트 합성)

Week 5-6: 품질 및 안전장치
├── QualityGateService (5가지 검증)
├── EscalationService (5단계 에스컬레이션)
├── TaskAnalyzerService (복잡도 분석, 서브태스크 분할)
├── FactCheckService (할루시네이션 방지 - 구문/실행/참조 검증)
├── DecisionLogService (일관성 보장 - 결정 기록/참조)
├── ConsistencyEnforcer (스타일 일관성 강제)
├── UncertaintyDecisionService (불확실성 의사결정)
│   ├── 되돌림 가능성 판단
│   ├── 비용/외부영향 체크
│   ├── Spike(Time-boxed 실험) 관리
│   └── 에스컬레이션 기준 적용
├── 비용 추적 및 제한
└── Human Approval 플로우
```

**MVP 완료 기준**:
- 단일 홀론이 태스크를 Pull하여 Brain Provider로 실행
- 결과물 품질 검증 및 실패 시 재시도/에스컬레이션
- 비용 한도 초과 시 작업 중단
- 생성된 코드 컴파일/테스트 검증 통과
- 동일 맥락 결정 일관성 유지
- 불확실성 상황에서 자율 판단 또는 적절한 에스컬레이션

---

### Phase 2: 협업 시스템

핵심 목표: **다수 홀론이 협업하여 프로젝트를 진행하는 메커니즘**

```
Week 7-8: 실시간 통신
├── PostgreSQL LISTEN/NOTIFY 연동
├── WebSocket Gateway
├── Message 시스템 (1:1, Channel)
└── 실시간 상태 동기화

Week 9-10: 정기 회의 자동화
├── MeetingScheduler (Cron 기반)
├── StandupService
│   ├── 일일 스탠드업 자동 트리거
│   ├── 각 홀론 진행상황 수집
│   └── 요약 리포트 생성 (Document)
├── SprintPlanningService
│   ├── 사이클 시작 시 자동 실행
│   ├── 백로그 우선순위 정렬
│   └── 태스크 할당 제안
└── RetrospectiveService
    ├── 사이클 종료 시 자동 실행
    ├── 메트릭 분석
    └── 개선점 Document 생성

Week 11-12: 협업 패턴
├── CollaborationService
│   ├── 페어 프로그래밍 모드 (두 홀론 동시 태스크)
│   ├── 코드 리뷰 플로우 (PR 생성 → 리뷰어 홀론 할당)
│   └── 브레인스토밍 세션 (Channel 기반)
├── CrossTeamCollaborationService
│   ├── 팀 간 의존성 요청/협상
│   ├── 인터페이스 계약 (Contract) 관리
│   └── 공유 채널 생성
├── IncidentResponseService
│   ├── 긴급 상황 자동 감지 (빌드 실패, 비용 급증 등)
│   ├── P1-P4 심각도 분류
│   ├── 자동 대응 (태스크 중단, Owner 할당)
│   └── Postmortem 자동 생성
└── ConflictResolutionService
    ├── 태스크 충돌 감지
    ├── 리소스 경합 해결
    └── 의견 불일치 시 팀 리더 중재
```

**Phase 2 완료 기준**:
- 3+ 홀론이 동시에 프로젝트 진행
- 일일 스탠드업 리포트 자동 생성
- 사이클 회고 문서 자동 생성
- 팀 간 의존성 요청 및 계약 체결
- P2 이상 긴급 상황 자동 대응

---

### Phase 3: 전략-실행 연결

핵심 목표: **고수준 목표가 실행 가능한 태스크로 자동 분해**

```
Week 13-14: 목표 관리 시스템
├── Goal Entity 추가
│   ├── 분기/월간/주간 목표
│   ├── OKR 구조 (Objective + Key Results)
│   └── 목표 계층 (Org → Team → Individual)
├── GoalTrackingService
│   ├── Key Result 진행률 자동 계산
│   ├── 목표 달성 예측
│   └── 리스크 조기 경보
└── GoalReviewService
    ├── 주간 목표 점검 자동화
    └── 조정 제안 생성

Week 15-16: 목표 → 태스크 분해
├── GoalDecompositionService
│   ├── 목표 분석 (LLM 기반)
│   ├── 프로젝트 자동 생성
│   ├── 마일스톤 설정
│   └── 태스크 트리 생성
├── DependencyAnalyzer
│   ├── 태스크 간 의존성 자동 추론
│   ├── 크리티컬 패스 계산
│   └── 병렬화 가능 태스크 식별
└── ResourcePlanner
    ├── 홀론 역량 매칭
    ├── 워크로드 밸런싱
    └── 병목 예측

Week 17-18: 동적 우선순위 및 전략 변경 대응
├── PriorityRebalancerService
│   ├── 블로커 발생 시 자동 재조정
│   ├── 데드라인 임박 시 우선순위 상향
│   ├── 의존성 완료 시 후속 태스크 활성화
│   └── 비용/시간 트레이드오프 최적화
├── PivotResponseService (전략 변경 대응)
│   ├── 영향받는 태스크/프로젝트 자동 식별
│   ├── 진행 중 작업 일시 중단 (suspended 상태)
│   ├── 재활용/보관/폐기 자산 분류
│   ├── 영향 분석 리포트 생성
│   └── 새 Goal 기반 태스크 분해 초안 제시
└── StrategyAdaptationService
    ├── 외부 환경 변화 감지 (사용자 입력)
    ├── 목표 수정 제안
    └── 진행 중 태스크 영향 분석
```

**Phase 3 완료 기준**:
- "신규 기능 X 출시" 목표 입력 → 프로젝트/마일스톤/태스크 자동 생성
- 블로커 발생 시 관련 태스크 우선순위 자동 조정
- 주간 목표 진행 리포트 자동 생성
- 피벗 선언 시 영향 분석 및 작업 재배치 자동화 (최종 승인은 인간)

---

### Phase 4: 학습 및 성장

핵심 목표: **홀론과 조직이 경험에서 학습하여 지속 개선**

```
Week 19-20: 온보딩 시스템
├── OnboardingService
│   ├── 신규 홀론 초기 학습 태스크 자동 할당
│   ├── 조직 컨텍스트 문서 주입
│   ├── 멘토 홀론 자동 매칭
│   └── 온보딩 완료 평가
└── SkillMatrixService
    ├── 홀론별 역량 프로파일
    ├── 태스크 완료 기반 역량 자동 업데이트
    └── 역량 갭 분석

Week 21-22: 지식 관리 고도화
├── KnowledgeExtractionService
│   ├── 태스크 완료 시 학습 가치 판단
│   ├── 패턴/인사이트 자동 추출
│   └── Document 자동 생성 (memory 타입)
├── KnowledgeGraphService
│   ├── 문서 간 관계 자동 연결
│   ├── 지식 검색 최적화
│   └── 중복/충돌 지식 감지
├── ExternalKnowledgeService
│   ├── 패키지 레지스트리 연동 (npm, PyPI)
│   ├── 허용된 외부 API 문서 접근
│   ├── 내부 시스템 상태 조회
│   └── 캐싱 및 접근 제한 (Whitelist)
└── BestPracticeService
    ├── 성공 패턴 자동 식별
    ├── 팀/조직 레벨 공유
    └── 프롬프트 개선 제안

Week 23-24: 자기 개선 시스템
├── PerformanceAnalyzer
│   ├── 홀론별 성과 트렌드 분석
│   ├── 팀 벨로시티 추적
│   └── 병목 자동 식별
├── PromptOptimizer
│   ├── A/B 테스트 자동 실행
│   ├── 프롬프트 변형 생성
│   └── 성과 기반 자동 선택
└── ProcessImprovementService
    ├── 반복 실패 패턴 감지
    ├── 워크플로우 개선 제안
    └── 자동 롤아웃 (승인 후)
```

**Phase 4 완료 기준**:
- 신규 홀론이 2-3개 태스크 후 정상 퍼포먼스 도달
- 반복 작업에서 자동 학습된 패턴 적용
- 월간 프로세스 개선 리포트 자동 생성

---

### Phase 5: 웹 UI 및 외부 연동

핵심 목표: **인간이 시스템을 모니터링하고 전략적 개입을 수행하는 인터페이스**

```
Week 25-26: 대시보드
├── Next.js 14 앱 설정
├── 조직도 뷰 (React Flow)
│   ├── 홀론 상태 실시간 표시
│   ├── 계층 구조 시각화
│   └── 드릴다운 네비게이션
├── 프로젝트 대시보드
│   ├── 번다운 차트
│   ├── 목표 진행률
│   └── 비용 사용량
└── 홀론 상세 뷰
    ├── 현재 작업 실시간 스트림
    ├── 히스토리
    └── 성과 메트릭

Week 27-28: 상호작용 인터페이스
├── 대화 인터페이스
│   ├── 특정 홀론과 1:1 대화
│   ├── 채널 그룹 대화
│   └── 명령어 시스템 (@홀론 /task ...)
├── 승인 센터
│   ├── 대기 중 승인 요청 목록
│   ├── 일괄 승인/거부
│   └── 조건부 자동 승인 규칙
└── 목표 설정 UI
    ├── OKR 에디터
    ├── 분해 결과 미리보기
    └── 수동 조정 인터페이스

Week 29-30: 외부 연동
├── GitHubIntegrationService
│   ├── PR 자동 생성
│   ├── 이슈 동기화
│   └── 코드 리뷰 연동
├── SlackIntegrationService
│   ├── 알림 전송
│   ├── 승인 요청 버튼
│   └── 스탠드업 리포트 공유
└── WebhookService
    ├── 외부 이벤트 수신
    ├── 태스크 자동 생성 트리거
    └── 커스텀 액션 실행
```

---

### 로드맵 요약

| Phase | 기간 | 핵심 결과물 | 시스템 상태 |
|-------|------|------------|------------|
| **Phase 1** | 6주 | 자율 실행 엔진 | 단일 홀론 자율 태스크 처리 |
| **Phase 2** | 6주 | 협업 시스템 | 다수 홀론 협업, 정기 회의 자동화 |
| **Phase 3** | 6주 | 전략-실행 연결 | 목표 → 태스크 자동 분해 |
| **Phase 4** | 6주 | 학습 및 성장 | 자기 개선, 지식 축적 |
| **Phase 5** | 6주 | UI 및 외부 연동 | 완전한 운영 환경 |

**총 예상 기간**: 30주 (약 7-8개월)

---

### 마일스톤별 검증 시나리오

**M1 (Phase 1 완료)**: "README 작성" 태스크를 홀론이 자율 수행
- 태스크 Pull → Brain Provider 실행 → 결과 검증 → 완료

**M2 (Phase 2 완료)**: 3명의 홀론이 "블로그 포스트 시리즈" 협업 완료
- 기획자 홀론: 주제 선정 → 작가 홀론: 초안 작성 → 편집자 홀론: 리뷰/수정
- 일일 스탠드업 리포트 3회 자동 생성

**M3 (Phase 3 완료)**: "신규 API 엔드포인트 3개 추가" 목표 입력 → 자동 실행
- 목표 → 프로젝트/마일스톤/태스크 자동 분해
- 태스크 의존성 자동 설정
- 홀론 자동 할당 및 실행

**M4 (Phase 4 완료)**: 동일 유형 태스크 5회 수행 후 효율성 20% 향상
- 학습된 패턴이 Memory에 저장
- 이후 태스크에서 자동 참조

**M5 (Phase 5 완료)**: 인간이 대시보드에서 전략만 설정하면 팀이 자율 운영
- 분기 OKR 입력 → 프로젝트 자동 생성 → 홀론들 자율 실행
- 예외 상황만 알림 및 승인 요청

---

## 13. 기술 스택

| 영역 | 기술 |
|------|------|
| **프론트엔드** | Next.js 14, React 18, TypeScript |
| **상태 관리** | Zustand 또는 Jotai |
| **시각화** | React Flow (조직도), Tailwind CSS |
| **백엔드** | NestJS, TypeScript |
| **실시간** | WebSocket + PostgreSQL LISTEN/NOTIFY |
| **데이터베이스** | PostgreSQL 16 |
| **ORM** | TypeORM 또는 Prisma |
| **에이전트** | Claude Code (기본), Gemini CLI, API 등 |
| **컨테이너** | Docker, Docker Compose |
| **빌드** | pnpm, Turborepo |

---

## 14. 리스크 및 고려사항

### 14.1 기술적 리스크

| 리스크 | 영향 | 대응 |
|--------|------|------|
| Brain Provider 프로세스 불안정 | 높음 | 재시작 메커니즘, 상태 DB 저장 |
| DB 연결 풀 고갈 | 중간 | 커넥션 풀링, 제한 설정 |
| API 비용 급증 | 높음 | 동시성 제한, 비용 모니터링 |

### 14.2 보안 고려사항

- 홀론별 파일 시스템 접근 제한
- 데이터베이스 접근 권한 분리 (홀론은 API 통해서만 접근)
- API 키 암호화 저장
- SQL Injection 방지 (ORM 사용)

---

## 15. 용어 정리

| 용어 | 정의 | 회사 비유 |
|------|------|----------|
| **Organization** | 최상위 컨테이너 | 회사 |
| **Role** | 역할 템플릿 (시스템 프롬프트, 권한 정의) | 직무 기술서 |
| **Team** | 홀론들의 그룹 | 부서/팀 |
| **Hollon** | Role 기반 에이전트 인스턴스 | 직원 |
| **Sub-Hollon** | 영구 홀론이 생성하는 임시 홀론 | 임시 외주 |
| **Project** | 목표 달성을 위한 작업 묶음 | 프로젝트 |
| **Milestone** | 프로젝트의 중요 이정표 | 마일스톤 |
| **Cycle** | 시간 기반 작업 단위 | 스프린트 |
| **Task** | 재귀적 작업 단위 | Linear 이슈 |
| **Channel** | 그룹 커뮤니케이션 공간 | Slack 채널 |
| **Document** | Markdown 기반 문서 | Wiki 페이지 |
| **Message** | 1:1 커뮤니케이션 | DM |
| **Brain Provider** | 홀론의 AI 두뇌 추상화 | 직원의 전문성 |
| **Decision Domain** | 역할의 의사결정 권한 범위 | 결정 권한 |
| **Autonomy Level** | 역할의 자율성 수준 | 권한 위임 수준 |
| **Metric** | 성과 측정 지표 | KPI |
| **Action Policy** | 액션별 처리 방식 (승인/보고/자율) | 결재 규정 |
| **Single Context** | 하나의 컨텍스트에서 하나의 태스크 완료 원칙 | 업무 집중 |
| **Prompt Hierarchy** | 6계층 프롬프트 합성 구조 | 조직 문화 전달 |
| **Memory (Document)** | Document 시스템의 Long-term Memory 역할 | 조직 지식 |
| **Escalation** | 문제 발생 시 단계적 상위 보고 | 보고 체계 |
| **Quality Gate** | 자율 운영의 품질 검증 체크포인트 | 품질 관리 |
| **Goal** | OKR 구조의 목표 (Objective + Key Results) | 분기/월간 목표 |
| **Goal Decomposition** | 목표 → 프로젝트 → 마일스톤 → 태스크 자동 분해 | 전략 실행 |
| **Standup** | 일일 진행상황 공유 자동 회의 | 데일리 스탠드업 |
| **Retrospective** | 사이클 종료 시 자동 생성 회고 | 스프린트 회고 |
| **Skill Matrix** | 홀론별 역량 프로파일 및 성장 추적 | 역량 평가표 |
| **Knowledge Graph** | 문서 간 관계 및 지식 연결망 | 조직 지식 체계 |
| **Onboarding** | 신규 홀론 초기 학습 프로세스 | 신입 온보딩 |
| **Decision Log** | 중요 결정 강제 기록 및 참조 시스템 | 의사결정 기록 |
| **Fact Check** | 생성 결과물의 구문/실행/참조 검증 | 품질 검수 |
| **Consistency Enforcer** | 코드/문서 스타일 일관성 강제 | 코딩 컨벤션 |
| **Incident** | 긴급 대응이 필요한 시스템 이슈 (P1-P4) | 장애 대응 |
| **Contract** | 팀 간 인터페이스/의존성 계약 | SLA/API 계약 |
| **External Knowledge** | 허용된 외부 정보 소스 접근 | 외부 자료 조회 |
| **Pivot** | 전략 방향 변경 (인간 승인 필요) | 사업 방향 전환 |
| **Pivot Response** | 피벗 시 영향 분석 및 작업 재배치 (자율) | 구조조정 실행 |
| **Spike** | 불확실성 해소를 위한 Time-boxed 실험 | 기술 검토 |
| **Uncertainty Decision** | 불완전 정보 하 의사결정 프레임워크 | 가설 기반 실행 |

---

## 문서 참조

- **구체적 구현 명세**: [blueprint.md](./blueprint.md) - DB 스키마, TypeScript 코드, API 정의

---

## 변경 이력

| 날짜 | 버전 | 변경 내용 |
|------|------|----------|
| 2024-12-03 | 0.1.0 | 초기 문서 작성 |
| 2024-12-03 | 0.2.0 | PostgreSQL 기반으로 변경 |
| 2024-12-03 | 0.3.0 | Role 개념 추가 |
| 2024-12-03 | 0.4.0 | Team, Channel, Document, 재귀적 Task 추가 |
| 2024-12-03 | 0.5.0 | Milestone/Cycle 추가, Document 파일시스템 스타일 변경 |
| 2024-12-03 | 0.6.0 | 성과 측정(Metrics) 시스템 추가 |
| 2024-12-03 | 0.7.0 | 자기 개선 시스템, 비용 통제, A/B 테스트 추가 |
| 2024-12-04 | 0.8.0 | Brain Provider 아키텍처 추가 |
| 2024-12-04 | 0.9.0 | 문서 분리: 개념(ssot.md) / 구현(blueprint.md) |
| 2024-12-04 | 1.0.0 | 자율 운영 모델 추가: Task 기반 운영, 프롬프트 계층, Document-Memory 통합, 자율 운영 정책 |
| 2024-12-04 | 1.1.0 | 기술 스택 변경 (NestJS + TypeORM/Prisma) |
| 2024-12-04 | 2.0.0 | 5단계 구현 로드맵 수립: MVP 코어 → 협업 → 전략-실행 → 학습 → UI/외부연동 |
| 2024-12-04 | 2.1.0 | LLM 한계 극복: DecisionLog, FactCheck, ConsistencyEnforcer, ExternalKnowledge |
| 2024-12-04 | 2.2.0 | 스타트업 요소 보완: 정기 회의 자동화, 크로스팀 협업, 긴급 대응 (Incident Response) |
| 2024-12-04 | 2.3.0 | 전략 변경 대응: PivotResponseService (자율 분석 + 인간 승인), 불확실성 의사결정 프레임워크 (Spike, 가설 기반 실행) |
